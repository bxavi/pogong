# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.16.0
# source: query.sql
from typing import Iterator, Optional

import sqlalchemy

from pyDAL import models


CREATE_ACCOUNTS = """-- name: create_accounts \\:one
INSERT INTO accounts (
	email, password
) VALUES (
	:p1, :p2
)
RETURNING id, email, password
"""


DELETE_ACCOUNTS = """-- name: delete_accounts \\:exec
DELETE FROM accounts
WHERE id = :p1
"""


GET_ACCOUNTS = """-- name: get_accounts \\:one
SELECT id, email, password FROM accounts
WHERE id = :p1  LIMIT 1
"""


LIST_ACCOUNTS = """-- name: list_accounts \\:many
SELECT id, email, password FROM accounts
ORDER BY email
"""


UPDATE_ACCOUNTS = """-- name: update_accounts \\:one
UPDATE accounts
set email = :p2,
password = :p3
WHERE id = :p1
RETURNING id, email, password
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_accounts(self, *, email: str, password: str) -> Optional[models.Accounts]:
        row = self._conn.execute(sqlalchemy.text(CREATE_ACCOUNTS), {"p1": email, "p2": password}).first()
        if row is None:
            return None
        return models.Accounts(
            id=row[0],
            email=row[1],
            password=row[2],
        )

    def delete_accounts(self, *, id: int) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_ACCOUNTS), {"p1": id})

    def get_accounts(self, *, id: int) -> Optional[models.Accounts]:
        row = self._conn.execute(sqlalchemy.text(GET_ACCOUNTS), {"p1": id}).first()
        if row is None:
            return None
        return models.Accounts(
            id=row[0],
            email=row[1],
            password=row[2],
        )

    def list_accounts(self) -> Iterator[models.Accounts]:
        result = self._conn.execute(sqlalchemy.text(LIST_ACCOUNTS))
        for row in result:
            yield models.Accounts(
                id=row[0],
                email=row[1],
                password=row[2],
            )

    def update_accounts(self, *, id: int, email: str, password: str) -> Optional[models.Accounts]:
        row = self._conn.execute(sqlalchemy.text(UPDATE_ACCOUNTS), {"p1": id, "p2": email, "p3": password}).first()
        if row is None:
            return None
        return models.Accounts(
            id=row[0],
            email=row[1],
            password=row[2],
        )
